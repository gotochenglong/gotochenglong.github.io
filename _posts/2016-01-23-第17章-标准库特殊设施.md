---
layout: post
title:  "第17章 标准库特殊设施"
date:   2016-01-23 17:47 +0800
category: 学习日志
tags:   C++_Primer
from:   http://www.cnblogs.com/qiusuo/p/5153709.html
---
<h2>17.1类型tuple</h2>
<p>tuple是类是pair的模板。每个pair都不相同，但是都有两个成员。而一个tuple类型会有任意数量的成员。（定义在tuple头文件中）</p>
<div>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>tuple&lt;T1,T2,...,Tn&gt; t;</p>
</td>
<td>
<p>t是一个tuple，成员数位n，第i个成员的类型为Ti。所有成员都进行值初始化</p>
</td>
</tr>
<tr>
<td>
<p>tuple&lt;T1,T2,...,Tn&gt; t(v1,v2,...,vn);</p>
</td>
<td>
<p>t是一个tuple，成员类型为T1,T2,...,Tn，每个成员用对应的初始值vi进行初始化。此构造函数是explicit的</p>
</td>
</tr>
<tr>
<td>
<p>make_tuple(v1,v2,...,vn);</p>
</td>
<td>
<p>返回一个用给定初始值初始化的tuple。tuple的类型从初始值的类型推断</p>
</td>
</tr>
<tr>
<td>
<p>t1 == t2</p>
<p>t1 != t2</p>
</td>
<td>
<p>当两个tulpe具有相同数量的成员对应相等时，两个tuple相等。这两个操作使用成员的==运算符来完成。一旦发现某对成员不等，接下来的成员就不用比较了</p>
</td>
</tr>
<tr>
<td>
<p>t1 relop t2</p>
</td>
<td>
<p>tuple的关系运算使用字典序。两个tuple必须具有相同数量成员。使用&lt;运算符比较t1的成员和t2的对应成员。</p>
</td>
</tr>
<tr>
<td>
<p>get&lt;i&gt;(t)</p>
</td>
<td>
<p>返回t的第i个成员的引用；如果t是一个左值，结果是一个左值引用；否则，结果是一个右值引用。tuple的所有成员都是public的</p>
</td>
</tr>
<tr>
<td>
<p>tuple_size&lt;tupleType&gt;::value</p>
</td>
<td>
<p>一个类模板，可以通过一个tuple类型来初始化，它有一个名为value的public constexpr static数据成员，类型为size_t，表示给定tuple类型中成员的数量</p>
</td>
</tr>
<tr>
<td>
<p>tuple_element&lt;i,tupleType&gt;::type</p>
</td>
<td>
<p>一个类模板，可以通过一个整型常量和一个tuple类型来初始化，它有一个名为type的public成员，表示给定tuple类型中指定成员的类型。</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>在关系比较中，两个tuple的类型必须相同（参数个数相同、类型相同）</p>
<p>成员访问</p>
<div class="cnblogs_code">
<pre>tuple&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">double</span>&gt; item = make_tuple(<span style="color: #800080;">8</span>, <span style="color: #800000;">"</span><span style="color: #800000;">success</span><span style="color: #800000;">"</span>, <span style="color: #800080;">3.1415926</span><span style="color: #000000;">);
cout </span>&lt;&lt; <span style="color: #0000ff;">get</span>&lt;<span style="color: #800080;">2</span>&gt;(item) &lt;&lt;<span style="color: #000000;"> endl;
</span><span style="color: #008000;">//</span><span style="color: #008000;">查询有多少个元素</span>
<span style="color: #000000;">typedef decltype(item) trans;
size_t sz </span>= tuple_size&lt;trans&gt;<span style="color: #000000;">::value;
</span><span style="color: #008000;">//</span><span style="color: #008000;">成员类型</span>
tuple_element&lt;<span style="color: #800080;">1</span>, trans&gt;::type second_value = <span style="color: #0000ff;">get</span>&lt;<span style="color: #800080;">1</span>&gt;(item);</pre>
</div>
<h3>17.1.2使用tuple返回多个值</h3>
<p>使用tuple的一个用处就是使用tuple可以让函数返回多个值。</p>
<div class="cnblogs_code">
<pre>typedef tuple&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">string</span>, <span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;"> result;
result Get_result()
{
    </span><span style="color: #0000ff;">return</span>  make_tuple(<span style="color: #800080;">8</span>, <span style="color: #0000ff;">string</span>(<span style="color: #800000;">"</span><span style="color: #800000;">success</span><span style="color: #800000;">"</span>), <span style="color: #800080;">3.1415926</span><span style="color: #000000;">);
}</span></pre>
</div>
<h2>17.2类型bitset</h2>
<p>将数据当做二进制位集合进行处理，并且可以指定任意的位数。定义在bitset头文件中。</p>
<div>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>bitset&lt;n&gt; b;</p>
</td>
<td>
<p>b有n位，每位都为0</p>
</td>
</tr>
<tr>
<td>
<p>bitset&lt;n&gt; b(u);</p>
</td>
<td>
<p>b是unsigned long型u的一个副本</p>
</td>
</tr>
<tr>
<td>
<p>bitset&lt;n&gt; b(s);</p>
</td>
<td>
<p>b是string对象s中含有的位串的副本</p>
</td>
</tr>
<tr>
<td>
<p>bitset&lt;n&gt; b(s, pos, m);</p>
</td>
<td>
<p>b是s中从位置pos开始的m个位的副本</p>
</td>
</tr>
<tr>
<td>
<p>bitset&lt;n&gt; b(s, pos, m);</p>
</td>
<td>
<p>b是s中从位置pos开始的m个位的副本</p>
</td>
</tr>
<tr>
<td>
<p>bitset&lt;n&gt; b(s, pos, m,zero,one);</p>
</td>
<td>
<p>b是s中从位置pos开始的m个位的副本</p>
</td>
</tr>
<tr>
<td>
<p>bitset&lt;n&gt; b(cp, pos, m,zero,one);</p>
</td>
<td>
<p>b是cp中从位置pos开始的m个位的副本</p>
</td>
</tr>
</tbody>
</table>
</div>
<p>如果使用一个数值初始化bitset，会首先将数值转换为unsigned long long类型，然后进行初始化</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">double 5.1转换成unsigned 5，二级制为101</span>
bitset&lt;<span style="color: #800080;">6</span>&gt; bt = <span style="color: #800080;">5.1</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;">输出为000101</span>
cout &lt;&lt; bt &lt;&lt; endl;</pre>
</div>
<p>如果使用string类型或者char数组类型初始化，则可以将字符中的0或1当成二进制进行处理</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">截断到前6位</span>
bitset&lt;<span style="color: #800080;">6</span>&gt; bt(<span style="color: #800000;">"</span><span style="color: #800000;">11100101</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;">输出为111001</span>
cout &lt;&lt; bt &lt;&lt; endl;</pre>
</div>
<h3><span lang="EN-US">17.2.2操作<span lang="EN-US">bitset</span></span></h3>
<div>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>b.any()</p>
</td>
<td>
<p>b中是否存在置为1的二进制位？</p>
</td>
</tr>
<tr>
<td>
<p>b.all()</p>
</td>
<td>
<p>b中是所有的二进制位都置为1？</p>
</td>
</tr>
<tr>
<td>
<p>b.none()</p>
</td>
<td>
<p>b中不存在置为1的二进制位吗？</p>
</td>
</tr>
<tr>
<td>
<p>b.count()</p>
</td>
<td>
<p>b中置为1的二进制位的个数</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.size()</p>
</td>
<td nowrap="nowrap">
<p>b中二进制位的个数</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.test(pos)</p>
</td>
<td nowrap="nowrap">
<p>b中在pos处的二进制位是否为1？</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.set(pos)</p>
</td>
<td nowrap="nowrap">
<p>把b中在pos处的二进制位置为1</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.set()</p>
</td>
<td nowrap="nowrap">
<p>把b中所有二进制位都置为1</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.reset(pos)</p>
</td>
<td nowrap="nowrap">
<p>把b中在pos处的二进制位置为0</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.reset()</p>
</td>
<td nowrap="nowrap">
<p>把b中所有二进制位都置为0</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.flip(pos)</p>
</td>
<td nowrap="nowrap">
<p>把b中在pos处的二进制位取反</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.flip()</p>
</td>
<td nowrap="nowrap">
<p>把b中所有二进制位逐位取反</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b[pos]</p>
</td>
<td nowrap="nowrap">
<p>访问b中在pos处的二进制位，如果b是const的，返回值为bool</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.to_ulong()</p>
</td>
<td nowrap="nowrap">
<p>用b中同样的二进制位返回一个unsigned long值</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.to_ullong()</p>
</td>
<td nowrap="nowrap">
<p>用b中同样的二进制位返回一个unsigned long long值</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>b.to_string(zero, one)</p>
</td>
<td nowrap="nowrap">
<p>返回一个string</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>os &lt;&lt; b</p>
</td>
<td nowrap="nowrap">
<p>把b中的位集以0/1输出到os流</p>
</td>
</tr>
<tr>
<td nowrap="nowrap">
<p>is &gt;&gt; b</p>
</td>
<td nowrap="nowrap">
<p>is流输入到b中</p>
</td>
</tr>
</tbody>
</table>
</div>
<h2>17.3正则表达式</h2>
<p>Regular expression can descripte a sequence of characters. The RE libraty is defined in header file &ldquo;regex&rdquo;, and its components are list</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>regex</p>
</td>
<td>
<p>Class that represents a regular expression</p>
</td>
</tr>
<tr>
<td>
<p>regex_match</p>
</td>
<td>
<p>Matches a sqequence of characters against a regular expression</p>
</td>
</tr>
<tr>
<td>
<p>regex_search</p>
</td>
<td>
<p>Finds the first subsequence that matches the regular expression</p>
</td>
</tr>
<tr>
<td>
<p>regex_replace</p>
</td>
<td>
<p>Replace a regular expression using a given format</p>
</td>
</tr>
<tr>
<td>
<p>sregex_iterator</p>
</td>
<td>
<p>Iterator adaptor that calls regex_search to iterate through the matches in a string</p>
</td>
</tr>
<tr>
<td>
<p>smatch</p>
</td>
<td>
<p>Container class that holds the results of searching a string</p>
</td>
</tr>
<tr>
<td>
<p>ssub_match</p>
</td>
<td>
<p>Results for a matched subexpression in a string</p>
</td>
</tr>
</tbody>
</table>
<h3><span lang="EN-US">17.3.1使用正则表达式匹配子串</span></h3>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">使用search得到匹配的子串</span>
<span style="color: #0000ff;">string</span> pattern(<span style="color: #800000;">"</span><span style="color: #800000;">\\d+</span><span style="color: #800000;">"</span><span style="color: #000000;">);
regex r(pattern);
smatch results;
</span><span style="color: #0000ff;">string</span> test_str = <span style="color: #800000;">"</span><span style="color: #800000;">123 456 789</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (regex_search(test_str, results, r))
    cout </span>&lt;&lt; results.str() &lt;&lt; endl;</pre>
</div>
<p><strong>指定regex</strong><strong>对象的选项</strong></p>
<p>When we define a regex or call assign on a regex to give it a new value, we can specify one or more flags that affect how the regex operates. In default, the flag is ECMAScript whitch is the regular expression language that many Web brower use.</p>
<p>&nbsp;</p>
<p>Regex选项</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>regex r(re)</p>
<p>regex r(re,f)</p>
<p>regex r=re</p>
</td>
<td>
<p>Define a regex with re and f.</p>
<p>F is flag. The default is ECMAScript</p>
</td>
</tr>
<tr>
<td>
<p>r.assign(re,f)</p>
</td>
<td>
<p>The same effect as assignment operator=</p>
</td>
</tr>
<tr>
<td>
<p>r.make_count()</p>
</td>
<td>
<p>Nember for subexpression r. (ex：&rdquo;abc(\d+)&rdquo;)</p>
</td>
</tr>
<tr>
<td>
<p>r.flags()</p>
</td>
<td>
<p>Return the flag set for r</p>
</td>
</tr>
</tbody>
</table>
<p>定义regex时指定的flag</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>icase</p>
</td>
<td>
<p>Ignore case(忽略大小写)</p>
</td>
</tr>
<tr>
<td>
<p>nosubs</p>
</td>
<td>
<p>Don&rsquo;t store the subexpression</p>
</td>
</tr>
<tr>
<td>
<p>Optimize</p>
</td>
<td>
<p>Favor speed of execution over speed of construction</p>
</td>
</tr>
<tr>
<td>
<p>ECMAScript</p>
</td>
<td>
<p>Using grammer as specified of ECMA-262</p>
</td>
</tr>
<tr>
<td>
<p>basic</p>
</td>
<td>
<p>Using grammer of POSIX</p>
</td>
</tr>
<tr>
<td>
<p>extended</p>
</td>
<td>
<p>Using grammer of POSIX extended</p>
</td>
</tr>
<tr>
<td>
<p>awk, grep, egrep</p>
</td>
<td>
<p>POSIX version of the awk, grep, egrep language</p>
</td>
</tr>
</tbody>
</table>
<p>如下</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">string</span> pattern(<span style="color: #800000;">"</span><span style="color: #800000;">\\d+</span><span style="color: #800000;">"</span><span style="color: #000000;">);
regex r(pattern,regex::icase);</span></pre>
</div>
<p>正则表达式是在运行时编译的，所以可能出现运行时错误，可以用如下捕获异常</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">try</span><span style="color: #000000;"> 
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> error: missing close bracket after alnum; the constructor will throw</span>
    regex r(<span style="color: #800000;">"</span><span style="color: #800000;">[[:alnum:]+\\.(cpp|cxx|cc)$</span><span style="color: #800000;">"</span><span style="color: #000000;">, regex::icase);
}
</span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (regex_error e)
{
    cout </span>&lt;&lt; e.what() &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\ncode: </span><span style="color: #800000;">"</span> &lt;&lt; e.code() &lt;&lt;<span style="color: #000000;"> endl;
}</span></pre>
</div>
<p>Error flag正则表达式错误类型</p>
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p><strong>flag</strong></p>
</td>
<td>
<p><strong>error</strong></p>
</td>
</tr>
<tr>
<td>
<p>error_collate</p>
</td>
<td>
<p>The expression contained an invalid collating element name.</p>
</td>
</tr>
<tr>
<td>
<p>error_ctype</p>
</td>
<td>
<p>The expression contained an invalid character class name.</p>
</td>
</tr>
<tr>
<td>
<p>error_escape</p>
</td>
<td>
<p>The expression contained an invalid escaped character, or a trailing escape.</p>
</td>
</tr>
<tr>
<td>
<p>error_backref</p>
</td>
<td>
<p>The expression contained an invalid back reference.</p>
</td>
</tr>
<tr>
<td>
<p>error_brack</p>
</td>
<td>
<p>The expression contained mismatched brackets ([&nbsp;and&nbsp;]).</p>
</td>
</tr>
<tr>
<td>
<p>error_paren</p>
</td>
<td>
<p>The expression contained mismatched parentheses ((&nbsp;and&nbsp;)).</p>
</td>
</tr>
<tr>
<td>
<p>error_brace</p>
</td>
<td>
<p>The expression contained mismatched braces ({&nbsp;and&nbsp;}).</p>
</td>
</tr>
<tr>
<td>
<p>error_badbrace</p>
</td>
<td>
<p>The expression contained an invalid range between braces ({&nbsp;and&nbsp;}).</p>
</td>
</tr>
<tr>
<td>
<p>error_range</p>
</td>
<td>
<p>The expression contained an invalid character range.</p>
</td>
</tr>
<tr>
<td>
<p>error_space</p>
</td>
<td>
<p>There was insufficient memory to convert the expression into a finite state machine.</p>
</td>
</tr>
<tr>
<td>
<p>error_badrepeat</p>
</td>
<td>
<p>The expression contained a repeat specifier (one of&nbsp;*?+{) that was not preceded by a valid regular expression.</p>
</td>
</tr>
<tr>
<td>
<p>error_complexity</p>
</td>
<td>
<p>The complexity of an attempted match against a regular expression exceeded a pre-set level.</p>
</td>
</tr>
<tr>
<td>
<p>error_stack</p>
</td>
<td>
<p>There was insufficient memory to determine whether the regular expression could match the specified character sequence.</p>
</td>
</tr>
</tbody>
</table>
<p><strong>正则表达式在运行时编译，而且很耗时，所以在循环中使用要慎重。</strong></p>
<p>&nbsp;</p>
<p>对于正则表达式有不同的字符串输入序列，所以由不同的处理方法：</p>
<p>正则表达式库类</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>string</p>
</td>
<td>
<p>regex, smatch, ssub_match, sregex_iterator</p>
</td>
</tr>
<tr>
<td>
<p>const char*</p>
</td>
<td>
<p>regex, cmatch, csub_match, cregex_iterator</p>
</td>
</tr>
<tr>
<td>
<p>wstring</p>
</td>
<td>
<p>wregex, wsmatch, wssub_match, wsregex_iterator</p>
</td>
</tr>
<tr>
<td>
<p>const wchar*</p>
</td>
<td>
<p>wregex, wcmatch, wcsub_match, wcregex_iterator</p>
</td>
</tr>
</tbody>
</table>
<h3>17.3.1匹配与Regex迭代器类型</h3>
<p>sregex_iterator操作</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>sregex_iterator it(b, e, r);</p>
</td>
<td>
<p>一个sregex_iterator，遍历迭代器b和e表示的string。它调用regex_search(b, e, m, r)将it定位到输入序列中第一个匹配的位置。</p>
</td>
</tr>
<tr>
<td>
<p>sregex_iterator end;</p>
</td>
<td>
<p>sregex_iterator的尾后迭代器。</p>
</td>
</tr>
<tr>
<td>
<p>*it</p>
<p>it-&gt;</p>
</td>
<td>
<p>根据最后一个调用regex_search的结果，返回一个smatch对象的引用或一个指向smatch对象的指针。</p>
</td>
</tr>
<tr>
<td>
<p>it++, &gt;, &lt;, !=, ==</p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
</tbody>
</table>
<p>使用regex迭代器</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> findthe characters ei that follow a character other than c</span>
<span style="color: #0000ff;">string</span> pattern(<span style="color: #800000;">"</span><span style="color: #800000;">\\d+</span><span style="color: #800000;">"</span><span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;"> we want the whole word in which our pattern appears</span>
pattern = <span style="color: #800000;">"</span><span style="color: #800000;">[[:alpha:]]*</span><span style="color: #800000;">"</span> + pattern + <span style="color: #800000;">"</span><span style="color: #800000;">[[:alpha:]]*</span><span style="color: #800000;">"</span><span style="color: #000000;">;
regex r(pattern, regex::icase); </span><span style="color: #008000;">//</span><span style="color: #008000;"> we'll ignore case in doing the match</span>
<span style="color: #0000ff;">string</span> file = <span style="color: #800000;">"</span><span style="color: #800000;">123 456 789</span><span style="color: #800000;">"</span><span style="color: #000000;">;
</span><span style="color: #008000;">//</span><span style="color: #008000;"> it will repeatedly call regex_search to find all matches in file</span>
<span style="color: #0000ff;">for</span><span style="color: #000000;"> (sregex_iterator it(file.begin(), file.end(), r), end_it;
it </span>!= end_it; ++<span style="color: #000000;">it)
    cout </span>&lt;&lt; it-&gt;str() &lt;&lt; endl; <span style="color: #008000;">//</span><span style="color: #008000;"> matched word</span></pre>
</div>
<p>sregex_iterator指向的smatch对象包含有很多细节，可以处理的操作为：</p>
<p>smatch操作</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>m.ready()</p>
</td>
<td>
<p>True if m has been set by a call to regex_search or regex_match, false otherwise. Operations on m are undefined if ready returns false</p>
</td>
</tr>
<tr>
<td>
<p>m.size()</p>
</td>
<td>
<p>Zero if the match failed; otherwise, one plus the number of subexpressions in the most recently matched regular expression.(返回子表达式的数量)</p>
</td>
</tr>
<tr>
<td>
<p>m.empty()</p>
</td>
<td>
<p>True if m.size() is zero</p>
</td>
</tr>
<tr>
<td>
<p>m.prefix()</p>
</td>
<td>
<p>An ssub_match representing the sequence befor the match</p>
</td>
</tr>
<tr>
<td>
<p>m.suffix()</p>
</td>
<td>
<p>An ssub_match representing the part after the end of the match</p>
</td>
</tr>
</tbody>
</table>
<p>对smatch中子表达式的操作(index 0 reprents the overall match)</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>m.length(n)</p>
</td>
<td>
<p>True if m.size() is zero</p>
</td>
</tr>
<tr>
<td>
<p>m.position(n)</p>
</td>
<td>
<p>Distance from the start of the sequence</p>
</td>
</tr>
<tr>
<td>
<p>m.str(n)</p>
</td>
<td>
<p>The matched string of nth subexpression</p>
</td>
</tr>
<tr>
<td>
<p>m[n]</p>
</td>
<td>
<p>ssub_match object correspending</p>
</td>
</tr>
<tr>
<td>
<p>m.begin(), m.end()</p>
<p>m.cbegin(), m.cend()</p>
</td>
<td>
<p>Iterator of ssub_match</p>
</td>
</tr>
</tbody>
</table>
<h3>17.3.3使用子表达式</h3>
<p>对于得到的子表达式结果ssub_match，有如下操作</p>
<p>子匹配操作</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>matched</p>
</td>
<td>
<p>是否匹配了</p>
</td>
</tr>
<tr>
<td>
<p>first</p>
</td>
<td>
<p>Distance from the start of the sequence</p>
</td>
</tr>
<tr>
<td>
<p>m.str(n)</p>
</td>
<td>
<p>The matched string of nth subexpression</p>
</td>
</tr>
<tr>
<td>
<p>m[n]</p>
</td>
<td>
<p>ssub_match object correspending</p>
</td>
</tr>
<tr>
<td>
<p>m.begin(), m.end()</p>
<p>m.cbegin(), m.cend()</p>
</td>
<td>
<p>Iterator of ssub_match</p>
</td>
</tr>
</tbody>
</table>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">for</span><span style="color: #000000;"> (sregex_iterator it(file.begin(), file.end(), r), end_it;
it </span>!= end_it; ++<span style="color: #000000;">it)
{
    cout </span>&lt;&lt; it-&gt;str() &lt;&lt; endl; <span style="color: #008000;">//</span><span style="color: #008000;"> matched word</span>
    cout &lt;&lt; it-&gt;length(<span style="color: #800080;">1</span>) &lt;&lt;<span style="color: #000000;"> endl; 
    cout </span>&lt;&lt; it-&gt;position(<span style="color: #800080;">2</span>) &lt;&lt;<span style="color: #000000;"> endl; 
    cout </span>&lt;&lt; it-&gt;<span style="color: #0000ff;">operator</span>[](<span style="color: #800080;">2</span>).matched &lt;&lt;<span style="color: #000000;"> endl;
    cout </span>&lt;&lt; it-&gt;<span style="color: #0000ff;">operator</span>[](<span style="color: #800080;">1</span>).length() &lt;&lt;<span style="color: #000000;"> endl;
}</span></pre>
</div>
<h3>17.3.4使用regex_replace</h3>
<p>当我们希望替换一个字符串中指定的部分，可以使用如下操作</p>
<p>正则表达式替换操作</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>m.formate(dest, fmt, mft)</p>
<p>m.formate(fmt, mft)</p>
</td>
<td>
<p>最后参数mft默认为formate_default，控制替换方法</p>
<p>dest,将结果存储的位置</p>
<p>fmt, 替换的字符串，eg：&ldquo;$2-$5-$7&rdquo;, $n表示子串</p>
</td>
</tr>
<tr>
<td>
<p>regex_replace(dest, seq, r, fmt, mft)</p>
<p>regex_replace(seq, r, fmt, mft)</p>
</td>
<td>
<p>同上</p>
</td>
</tr>
</tbody>
</table>
<p>例子</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> findthe characters ei that follow a character other than c</span>
<span style="color: #0000ff;">string</span> pattern(<span style="color: #800000;">"</span><span style="color: #800000;">([[:alpha:]]+)(\\d+)([[:alpha:]]+)(\\d+)([[:alpha:]]+)(\\d+)([[:alpha:]]+)</span><span style="color: #800000;">"</span><span style="color: #000000;">);
regex r(pattern, regex::icase); </span><span style="color: #008000;">//</span><span style="color: #008000;"> we'll ignore case in doing the match</span>
<span style="color: #0000ff;">string</span> file = <span style="color: #800000;">"</span><span style="color: #800000;">ffffff123aaa456bbb789ccc</span><span style="color: #800000;">"</span><span style="color: #000000;">;
cout </span>&lt;&lt; regex_replace(file, r, <span style="color: #800000;">"</span><span style="color: #800000;">$1-$2-$3</span><span style="color: #800000;">"</span>) &lt;&lt;<span style="color: #000000;"> endl;
    
smatch results;
regex_search(file, results, r);
cout </span>&lt;&lt; results.format(<span style="color: #800000;">"</span><span style="color: #800000;">$1-$2-$3</span><span style="color: #800000;">"</span>)&lt;&lt; endl;</pre>
</div>
<p><strong>控制匹配和格式的标识mft</strong></p>
<p>需要使用如下命名空间</p>
<p>using std::regex_constants::format_no_copy;</p>
<p>或者</p>
<p>using namespacestd::regex_constants;</p>
<p>匹配标识</p>
<p>&nbsp;</p>
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p align="center"><strong>flag*</strong></p>
</td>
<td>
<p align="center"><strong>effects on match</strong></p>
</td>
<td>
<p align="center"><strong>notes</strong></p>
</td>
</tr>
<tr>
<td>
<p align="left"><tt>match_default</tt></p>
</td>
<td>
<p>Default</p>
</td>
<td>
<p>Default matching behavior.<br />
  This constant has a value of zero**.</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>match_not_bol</tt></p>

  </td>
<td>
<p>Not Beginning-Of-Line</p>

  </td>
<td>
<p>The first character is not considered a&nbsp;<em>beginning of line</em>&nbsp;(<tt>"^"</tt>&nbsp;does not match).</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>match_not_eol</tt></p>

  </td>
<td>
<p>Not End-Of-Line</p>

  </td>
<td>
<p>The last character is not considered an&nbsp;<em>end of line</em>&nbsp;(<tt>"$"</tt>&nbsp;does not match).</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>match_not_bow</tt></p>

  </td>
<td>
<p>Not Beginning-Of-Word</p>

  </td>
<td>
<p>The escape sequence&nbsp;<tt>"\b"</tt>&nbsp;does not match as a&nbsp;<em>beginning-of-word</em>.</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>match_not_eow</tt></p>

  </td>
<td>
<p>Not End-Of-Word</p>

  </td>
<td>
<p>The escape sequence&nbsp;<tt>"\b"</tt>&nbsp;does not match as an&nbsp;<em>end-of-word</em>.</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>match_any</tt></p>

  </td>
<td>
<p>Any match</p>

  </td>
<td>
<p>Any match is acceptable if more than one match is possible.</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>match_not_null</tt></p>

  </td>
<td>
<p>Not null</p>

  </td>
<td>
<p>Empty sequences do not match.</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>match_continuous</tt></p>

  </td>
<td>
<p>Continuous</p>

  </td>
<td>
<p>The expression must match a sub-sequence that begins at the
  first character.<br />
  Sub-sequences must begin at the first character to match.</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>match_prev_avail</tt></p>

  </td>
<td>
<p>Previous Available</p>

  </td>
<td>
<p>One or more characters exist before the first one. (<tt>match_not_bol</tt>&nbsp;and<tt>match_not_bow</tt>&nbsp;are ignored)</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>format_default</tt></p>

  </td>
<td>
<p>Default</p>

  </td>
<td>
<p>Same as&nbsp;<tt>match_default</tt>.<br />
  This constant has a value of zero**.</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>format_sed</tt></p>

  </td>
<td rowspan="3">
<p>None</p>

  </td>
<td rowspan="3">
<p>Ignored by this function.<br />
  See&nbsp;<a href="http://www.cplusplus.com/regex_constants">regex_constants</a>&nbsp;for more info.</p>

  </td>

 </tr>
<tr>
<td>
<p><tt>format_no_copy</tt></p>

  </td>

 </tr>
<tr>
<td>
<p><tt>format_first_only</tt></p>

  </td>

 </tr>

</tbody>

</table>
<h2>17.4随机数</h2>
<p>旧标准使用见的C函数rand生成随机数，生成0到系统相关的最大值（至少为32767）之间的均匀分布的随机数。</p>
<p>定义在random中的随机数库通过一组写作的类，扩展随机数（自定义随机数范围、随机浮点数）：random-number engines and random-number distribution.</p>
<p>其中random-number engines生成随机的unsigned整数序列</p>
<p>random-number distribution使用随机数引擎返回已制定的随机数分布。</p>
<h3>17.4.1随机数引擎和分布</h3>
<p>reproduce from http://www.cplusplus.com/reference/random/</p>
<p><strong><em><span style="text-decoration: underline;">Generator</span></em></strong></p>
<p><strong>Pseudo-random number engines (templates)</strong></p>
<p>Generators that use an algorithm to generate pseudo-random numbers based on an initial seed:</p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>linear_congruential_engine</p>

</td>
<td>
<p>Linear congruential random number engine (class template )</p>

</td>

</tr>
<tr>
<td>
<p>mersenne_twister_engine</p>

</td>
<td>
<p>Mersenne twister random number engine (class template )</p>

</td>

</tr>
<tr>
<td>
<p>subtract_with_carry_engine</p>

</td>
<td>
<p>Subtract-with-carry random number engine (class template )</p>

</td>

</tr>

</tbody>

</table>
<p><strong>Engine adaptors</strong></p>
<p>They adapt an engine, modifying the way numbers are generated with it:</p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>discard_block_engine</p>

</td>
<td>
<p>Discard-block random number engine adaptor (class template )</p>

</td>

</tr>
<tr>
<td>
<p>independent_bits_engine</p>

</td>
<td>
<p>Independent-bits random number engine adaptor (class template )</p>

</td>

</tr>
<tr>
<td>
<p>shuffle_order_engine</p>

</td>
<td>
<p>Shuffle-order random number engine adaptor (class template )</p>

</td>

</tr>

</tbody>

</table>
<p><strong>Pseudo-random number engines (instantiations)</strong></p>
<p>Particular instantiations of generator engines and adaptors:</p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>default_random_engine</p>

</td>
<td>
<p>Default random engine (class )</p>

</td>

</tr>
<tr>
<td>
<p>minstd_rand</p>

</td>
<td>
<p>Minimal Standard minstd_rand generator (class )</p>

</td>

</tr>
<tr>
<td>
<p>minstd_rand0</p>

</td>
<td>
<p>Minimal Standard minstd_rand0 generator (class )</p>

</td>

</tr>
<tr>
<td>
<p>mt19937</p>

</td>
<td>
<p>Mersenne Twister 19937 generator (class )</p>

</td>

</tr>
<tr>
<td>
<p>mt19937_64</p>

</td>
<td>
<p>Mersene Twister 19937 generator (64 bit) (class )</p>

</td>

</tr>
<tr>
<td>
<p>ranlux24_base</p>

</td>
<td>
<p>Ranlux 24 base generator (class )</p>

</td>

</tr>
<tr>
<td>
<p>ranlux48_base</p>

</td>
<td>
<p>Ranlux 48 base generator (class )</p>

</td>

</tr>
<tr>
<td>
<p>ranlux24</p>

</td>
<td>
<p>Ranlux 24 generator (class )</p>

</td>

</tr>
<tr>
<td>
<p>ranlux48</p>

</td>
<td>
<p>Ranlux 48 generator (class )</p>

</td>

</tr>
<tr>
<td>
<p>knuth_b</p>

</td>
<td>
<p>Knuth-B generator (class )</p>

</td>

</tr>

</tbody>

</table>
<p><strong>Random number generators</strong></p>
<p>Non-deterministic random number generator:</p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>random_device</p>

</td>
<td>
<p>True random number generator (class )</p>

</td>

</tr>

</tbody>

</table>
<p><strong><em><span style="text-decoration: underline;">Distributions</span></em></strong></p>
<p><strong>Uniform:</strong></p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>uniform_int_distribution</p>

</td>
<td>
<p>Uniform discrete distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>uniform_real_distribution</p>

</td>
<td>
<p>Uniform real distribution (class template )</p>

</td>

</tr>

</tbody>

</table>
<p><strong>Related to Bernoulli (yes/no) trials:</strong></p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>bernoulli_distribution</p>

</td>
<td>
<p>Bernoulli distribution (class )</p>

</td>

</tr>
<tr>
<td>
<p>binomial_distribution</p>

</td>
<td>
<p>Binomial distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>geometric_distribution</p>

</td>
<td>
<p>Geometric distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>negative_binomial_distribution</p>

</td>
<td>
<p>Negative binomial distribution (class template )</p>

</td>

</tr>

</tbody>

</table>
<p><strong>Rate-based distributions:</strong></p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>poisson_distribution</p>

</td>
<td>
<p>Poisson distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>exponential_distribution</p>

</td>
<td>
<p>Exponential distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>gamma_distribution</p>

</td>
<td>
<p>Gamma distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>weibull_distribution</p>

</td>
<td>
<p>Weibull distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>extreme_value_distribution</p>

</td>
<td>
<p>Extreme Value distribution (class template )</p>

</td>

</tr>

</tbody>

</table>
<p><strong>Related to Normal distribution:</strong></p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>normal_distribution</p>

</td>
<td>
<p>Normal distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>lognormal_distribution</p>

</td>
<td>
<p>Lognormal distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>chi_squared_distribution</p>

</td>
<td>
<p>Chi-squared distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>cauchy_distribution</p>

</td>
<td>
<p>Cauchy distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>fisher_f_distribution</p>

</td>
<td>
<p>Fisher F-distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>student_t_distribution</p>

</td>
<td>
<p>Student T-Distribution (class template )</p>

</td>

</tr>

</tbody>

</table>
<p><strong>Piecewise distributions:</strong></p>
<table cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>discrete_distribution</p>

</td>
<td>
<p>Discrete distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>piecewise_constant_distribution</p>

</td>
<td>
<p>Piecewise constant distribution (class template )</p>

</td>

</tr>
<tr>
<td>
<p>piecewise_linear_distribution</p>

</td>
<td>
<p>Piecewise linear distribution (class template )</p>

</td>

</tr>

</tbody>

</table>
<p>&nbsp;<strong>Other</strong></p>
<p>&nbsp;</p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>seed_seq</p>

</td>
<td>
<p>Seed sequence (class )</p>

</td>

</tr>
<tr>
<td>
<p>generate_canonical</p>

</td>
<td>
<p>Generate canonical numbers (function template )</p>

</td>

</tr>

</tbody>

</table>
<p><strong>随机数引擎操作</strong></p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>Engine e;</p>

</td>
<td>
<p>默认构造，使用默认种子</p>

</td>

</tr>
<tr>
<td>
<p>Engine e(s)</p>

</td>
<td>
<p>使用自定义种子</p>

</td>

</tr>
<tr>
<td>
<p>e.seed(s)</p>

</td>
<td>
<p>&nbsp;</p>

</td>

</tr>
<tr>
<td>
<p>e.min(), e.max()</p>

</td>
<td>
<p>&nbsp;</p>

</td>

</tr>
<tr>
<td>
<p>Engine::result_type</p>

</td>
<td>
<p>&nbsp;</p>

</td>

</tr>
<tr>
<td>
<p>e.discard(u)</p>

</td>
<td>
<p>将引擎推动u步，u is unsigned long long</p>

</td>

</tr>

</tbody>

</table>
<p>&nbsp;</p>
<p>使用random引擎</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">default_random_engine e;
</span><span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; ++<span style="color: #000000;">i)
    cout </span>&lt;&lt; e() &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t</span><span style="color: #800000;">"</span>;</pre>
</div>
<p><strong>提示：为了每次调用随机数引擎得到不同的随机数，可以将随机数引擎声明成static</strong><strong>的</strong>，<strong>或者通过时间</strong><strong>&lt;ctime&gt;</strong><strong>作为随机数种子：default_rand_engine e(time(0))</strong></p>
<h3>17.4.2其他随机数分布</h3>
<p>使用分布类型 - 指定随机数范围</p>
<div class="cnblogs_code">
<pre>uniform_int_distribution&lt;unsigned&gt; u(<span style="color: #800080;">0</span>, <span style="color: #800080;">9</span><span style="color: #000000;">);
default_random_engine e;
</span><span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; ++<span style="color: #000000;">i)
    cout </span>&lt;&lt; u(e) &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t</span><span style="color: #800000;">"</span>;</pre>
</div>
<p>使用分布类型 &ndash; 浮点数</p>
<div class="cnblogs_code">
<pre>uniform_real_distribution&lt;<span style="color: #0000ff;">double</span>&gt; u(<span style="color: #800080;">0</span>, <span style="color: #800080;">6</span><span style="color: #000000;">);
default_random_engine e;
</span><span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; ++<span style="color: #000000;">i)
    cout </span>&lt;&lt; u(e) &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t</span><span style="color: #800000;">"</span>; </pre>
</div>
<p>使用分布类型 &ndash; 正态分布</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">均值为4，标准差1.5</span>
normal_distribution&lt;<span style="color: #0000ff;">double</span>&gt; u(<span style="color: #800080;">4</span>,<span style="color: #800080;">1.5</span><span style="color: #000000;">);
default_random_engine e;
</span><span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; ++<span style="color: #000000;">i)
    cout </span>&lt;&lt; u(e) &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t</span><span style="color: #800000;">"</span>; </pre>
</div>
<p>使用分布类型 &ndash; bool值</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">为true的概率为0.7</span>
bernoulli_distribution u(<span style="color: #800080;">0.7</span><span style="color: #000000;">);
default_random_engine e;
</span><span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">0</span>; i &lt; <span style="color: #800080;">10</span>; ++<span style="color: #000000;">i)
    cout </span>&lt;&lt; u(e) &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\t</span><span style="color: #800000;">"</span>;</pre>
</div>
<p>分布类型操作</p>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>Dist d;</p>
</td>
<td>
<p>默认构造，使用默认种子</p>
</td>
</tr>
<tr>
<td>
<p>Dist d(e)</p>
</td>
<td>
<p>使用自定义种子</p>
</td>
</tr>
<tr>
<td>
<p>d.min(), d.max()</p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p>d.reset()</p>
</td>
<td>
<p>重新生成</p>
</td>
</tr>
</tbody>
</table>
<h2>17.5再探IO库</h2>
<p>在iostream对象中，处理维护一个状态条件外，还维护了一个格式状态来控制IO如何格式化的细节，比如整型是几进制、浮点值的精度、一个输出元素的宽度。为此，标准库定义了一组操纵符（manipulator）。</p>
<p>操纵符用于两大类输出控制：控制数值输出的形式、控制补白的数量和位置。大多数改变格式状态的操纵符都是设置/复原<strong>成对</strong>的。</p>
<p>Eg：cout&lt;&lt;boolalpha&lt;&lt;true&lt;&lt;endl;</p>
<p><strong>控制布尔值的格式</strong></p>
<p>boolalpha noboolalpha</p>
<p><strong>指定整型值的进制（不显示前缀0x</strong><strong>、0</strong><strong>）</strong></p>
<p>hex、oct、dec：十六进制、八进制、改回十进制</p>
<p><strong>显示进制前缀0x</strong><strong>、0</strong></p>
<p>showbase、noshowbase</p>
<p><strong>大小写输出缀X</strong><strong>、x</strong><strong>，E</strong><strong>、e</strong></p>
<p>uppercase、nouppercase</p>
<p><strong>控制浮点数格式</strong></p>
<p>使用cout.precision()返回当前精度</p>
<p>精度：setprecision(n), 或者对io对象cout.precision(n)</p>
<p>总是显示小数点：showpoint、noshowpoint(当腹地安置包含小数部分才显示)</p>
<p>对非负数显示+：showpos、noshowpos</p>
<p>对齐方式：left、right</p>
<p>符号值之间填充字符：internal</p>
<p>定点十进制：fixed</p>
<p>科学计数法：scientific</p>
<p>十六进制浮点：hexfloat，重置为double：defaultfloat</p>
<p>每次输出都刷新缓冲区：unitbuf、nounitbuf</p>
<p>输出运算符跳过空白符：skipws、noskipws</p>
<p>刷新缓冲区：flush</p>
<p>空字符，并刷新：\0</p>
<p>换行，并刷新：</p>
<h3>17.5.2未格式化的输入/输出操作</h3>
<p>未格式化IO操作，允许我们将一个流当做一个无解释的字节序列处理。</p>
<p><strong>单字节操作</strong></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>is.get(ch)</p>
</td>
<td>
<p>Put the next byte in ch, then return is</p>
</td>
</tr>
<tr>
<td>
<p>os.put(ch)</p>
</td>
<td>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td>
<p>is.get()</p>
</td>
<td>
<p>Return next byte as int</p>
</td>
</tr>
<tr>
<td>
<p>is.putback(ch)</p>
</td>
<td>
<p>Put the character ch back on is; return is</p>
</td>
</tr>
<tr>
<td>
<p>is.unget()</p>
</td>
<td>
<p>Move is back on byte; return is</p>
</td>
</tr>
<tr>
<td>
<p>is.peek()</p>
</td>
<td>
<p>Return next byte as int, don&rsquo;t remove it</p>
</td>
</tr>
</tbody>
</table>
<p><strong>多字节操作</strong></p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>Is.get(sink, size, delim)</p>
</td>
<td>
<p>读取size个byte到sink，其中遇见delim、文件尾停止，delim留在流中不读取</p>
</td>
</tr>
<tr>
<td>
<p>Is.getline(sink, size, delim)</p>
</td>
<td>
<p>同上，单会读取delim并丢弃delim</p>
</td>
</tr>
<tr>
<td>
<p>Is.read(sink, size)</p>
</td>
<td>
<p>读取最多size，存入sink，返回is</p>
</td>
</tr>
<tr>
<td>
<p>Is.gcount()</p>
</td>
<td>
<p>返回上一个未格式化读取操作从is读取的字节数</p>
</td>
</tr>
<tr>
<td>
<p>Os.write(source, size)</p>
</td>
<td>
<p>Source的size字节写入os，返回os</p>
</td>
</tr>
<tr>
<td>
<p>Is.ignore(size,delim)</p>
</td>
<td>
<p>忽略最多size个字符，包括delim，in default,size=1 &amp; delim is EOF</p>
</td>
</tr>
</tbody>
</table>
<h3>17.5.3流的随机访问</h3>
<p>标准库定义了seek和tell，单不是所有的流都会你有意义，依赖于绑定到上边的设备，如对于cin、cout、ceer和clog流不支持随机访问。</p>
<p>Seek和tell函数（g表示正在读取get，p表示放入put）</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td width="150px">
<p>tellg()</p>
<p>tellp()</p>
</td>
<td>
<p>当前位置</p>
</td>
</tr>
<tr>
<td>
<p>seekg(pos)</p>
<p>seekp(pos)</p>
</td>
<td>
<p>重定位到给定的绝对地址，pos通常是前一个tellg或者tellp返回的值</p>
</td>
</tr>
<tr>
<td>
<p>seekp(off, from)</p>
<p>seekp(off, from)</p>
</td>
<td>
<p>From可以为beg（流开始）、cur（当前）、end（流结尾）3，off可以为正或者负数</p>
</td>
</tr>
</tbody>
</table>
<p>读写同一个文件</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 打开文献，并定位到文件尾</span>
    fstream inOut(<span style="color: #800000;">"</span><span style="color: #800000;">copyOut</span><span style="color: #800000;">"</span>,fstream::ate | fstream::<span style="color: #0000ff;">in</span> | fstream::<span style="color: #0000ff;">out</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">inOut) 
    {
        cerr </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">Unable to open file!</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> endl;
        </span><span style="color: #0000ff;">return</span> EXIT_FAILURE; <span style="color: #008000;">//</span><span style="color: #008000;"> 错误返回</span>
<span style="color: #000000;">    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 记录当前读取位置</span>
    auto end_mark =<span style="color: #000000;"> inOut.tellg();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 转到文件头部</span>
    inOut.seekg(<span style="color: #800080;">0</span><span style="color: #000000;">, fstream::beg);
    size_t cnt </span>= <span style="color: #800080;">0</span>;  <span style="color: #008000;">//</span><span style="color: #008000;"> 收集了byte的个数</span>
    <span style="color: #0000ff;">string</span><span style="color: #000000;"> line;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">将文件中的内容重复到文件最后</span>
    <span style="color: #0000ff;">while</span> (inOut &amp;&amp; inOut.tellg() != end_mark &amp;&amp;<span style="color: #000000;"> getline(inOut, line)) 
    {
        cnt </span>+= line.size() + <span style="color: #800080;">1</span>;<span style="color: #008000;">//</span><span style="color: #008000;">1是最后的换行符</span>
        auto mark = inOut.tellg();  <span style="color: #008000;">//</span><span style="color: #008000;"> remember the read position</span>
        inOut.seekp(<span style="color: #800080;">0</span>, fstream::end); <span style="color: #008000;">//</span><span style="color: #008000;"> set the write marker to the end</span>
        inOut &lt;&lt; cnt;  <span style="color: #008000;">//</span><span style="color: #008000;"> write the accumulated length
                           </span><span style="color: #008000;">//</span><span style="color: #008000;"> print a separator if this is not the last line</span>
        <span style="color: #0000ff;">if</span> (mark != end_mark) inOut &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span><span style="color: #000000;">;
        inOut.seekg(mark);  </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回读取的位置</span>
<span style="color: #000000;">    }
    inOut.seekp(</span><span style="color: #800080;">0</span>, fstream::end);  <span style="color: #008000;">//</span><span style="color: #008000;"> seek to the end</span>
    inOut &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">\n</span><span style="color: #800000;">"</span>;    <span style="color: #008000;">//</span><span style="color: #008000;"> write a newline at end-offile</span>
    <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
