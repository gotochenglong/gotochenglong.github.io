---
layout: post
title:  "第16章 模板与泛型编程"
date:   2016-01-22 21:25 +0800
category: 学习日志
tags:   C++_Primer
from:   http://www.cnblogs.com/qiusuo/p/5152406.html
---
<h3>16.1.1函数模板</h3>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">template parameter list</span>
template&lt;typename T1,typename T2&gt;
<span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> T1&amp; v1, <span style="color: #0000ff;">const</span> T2&amp;<span style="color: #000000;">v2)
{
    </span><span style="color: #0000ff;">if</span> (v1 &lt; v2) <span style="color: #0000ff;">return</span> -<span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span> (v2 &lt; v1) <span style="color: #0000ff;">return</span> <span style="color: #800080;">1</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>When we call a function template, the compiler (ordinarily) uses the arguments of the call to deduce the template parameter(s) for us.</p>
<p>The compiler uses the deduced template parameter(s) to instantiatea specific version of the function for us.</p>
<p><strong>模板类型参数</strong></p>
<p>函数模板的参数列表必须明确标明typename或者class，两个是同义的（typename在模板引入C++之后才出现，很多早先的程序使用class）</p>
<p><strong>非类型模板参数</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> 整数</span>
template&lt;unsigned N, unsigned M&gt;
<span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>(&amp;p1)[N], <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>(&amp;<span style="color: #000000;">p2)[M])
{
    strcpy(p1,p2);
}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 指针</span>
template&lt;<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* C&gt;
<span style="color: #0000ff;">void</span> func1(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*<span style="color: #000000;"> str)
{
    cout </span>&lt;&lt; C &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> &lt;&lt; str &lt;&lt;<span style="color: #000000;"> endl;
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 引用</span>
template&lt;<span style="color: #0000ff;">char</span>(&amp;R)[<span style="color: #800080;">9</span>]&gt;
<span style="color: #0000ff;">void</span> func2(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*<span style="color: #000000;"> str)
{
    cout </span>&lt;&lt; R &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> &lt;&lt; str &lt;&lt;<span style="color: #000000;"> endl;
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> 函数指针</span>
template&lt;<span style="color: #0000ff;">void</span>(*f)(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*)&gt;
<span style="color: #0000ff;">void</span> func3(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>*<span style="color: #000000;"> c)
{
    f(c);
}
</span><span style="color: #0000ff;">void</span> print(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* c) { cout &lt;&lt; c &lt;&lt;<span style="color: #000000;"> endl; }
</span><span style="color: #0000ff;">char</span> arr[<span style="color: #800080;">9</span>] = <span style="color: #800000;">"</span><span style="color: #800000;">template</span><span style="color: #800000;">"</span>;   <span style="color: #008000;">//</span><span style="color: #008000;"> 全局变量，具有静态生存期</span>
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    func1</span>&lt;arr&gt;(<span style="color: #800000;">"</span><span style="color: #800000;">pointer</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    func2</span>&lt;arr&gt;(<span style="color: #800000;">"</span><span style="color: #800000;">reference</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    func3</span>&lt;print&gt;(<span style="color: #800000;">"</span><span style="color: #800000;">template function pointer</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>绑定到非类型整型的实参必须是一个常量表达式，绑定到指针或引用的非类型参数的实参必须有静态的生存期（比如全局变量）</p>
<p><strong>inline</strong><strong>和constexpr</strong><strong>的函数模板</strong></p>
<div class="cnblogs_code">
<pre>template&lt;typename T1, typename T2&gt; inline <span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> T1&amp; v1, <span style="color: #0000ff;">const</span> T2&amp;<span style="color: #000000;">v2);
template</span>&lt;typename T1, typename T2&gt; constexpr <span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> T1&amp; v1, <span style="color: #0000ff;">const</span> T2&amp;v2);</pre>
</div>
<p>&nbsp;</p>
<p>对于函数模板，编译器可以通过参数推断，得出模板中的类型信息，因而在使用函数模板时可以省略&lt;typeName&gt;。</p>
<h3>16.1.2类模板</h3>
<p>对于函数模板，编译器可以通过参数推断，得出模板中的类型信息，因而在使用函数模板时可以省略&lt;typeName&gt;。对于类模板，必须在模板后的尖括号中提供信息，代替模板参数实参列表。</p>
<ol>
<li>类模板中，模板参数被被当做stand-ins（替身），使用时被替换</li>
<li>类模板中的成员函数只有在使用时才会被实例化，这使的某种类型即使不完全符合模板要求，仍然可以使用该类型的模板。</li>
<li>实例化后的类型为ClassName&lt;typeName&gt;类型。</li>
<li>类包含友元时，模板类包含非模板友元，则友元可以访问模板的所有类型实例；友元是模板，则所有的友元实例都可以访问模板类的所有实例。</li>
<li>对于static成员，每一个不同类型实例，都有不同的static成员，相同类型的实例实例化出来的对象共享static成员。</li>
</ol>
<div class="cnblogs_code" onclick="cnblogs_code_show('9406929c-9e1a-49e6-a304-188e89a7eb16')"><img id="code_img_closed_9406929c-9e1a-49e6-a304-188e89a7eb16" class="code_img_closed" src="http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_9406929c-9e1a-49e6-a304-188e89a7eb16" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('9406929c-9e1a-49e6-a304-188e89a7eb16',event)" src="http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_9406929c-9e1a-49e6-a304-188e89a7eb16" class="cnblogs_code_hide">
<pre>#include&lt;memory&gt;<span style="color: #000000;">
#include </span>&lt;vector&gt;
<span style="color: #0000ff;">using</span> <span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std;

template </span>&lt;typename&gt; <span style="color: #0000ff;">class</span> BlobPtr;<span style="color: #008000;">//</span><span style="color: #008000;"> forward declarations needed for friend declarations in Blob</span>
template &lt;typename&gt; <span style="color: #0000ff;">class</span> Blob; <span style="color: #008000;">//</span><span style="color: #008000;"> needed for parameters in operator==</span>
<span style="color: #000000;">
template </span>&lt;typename T&gt;
<span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>==(<span style="color: #0000ff;">const</span> Blob&lt;T&gt;&amp;, <span style="color: #0000ff;">const</span> Blob&lt;T&gt;&amp;<span style="color: #000000;">);
template</span>&lt;typename T&gt; <span style="color: #0000ff;">class</span><span style="color: #000000;"> Blob
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> each instantiation of Blob grants access to the version of
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> BlobPtr and the equality operator instantiated with the same type</span>
    friend <span style="color: #0000ff;">class</span> BlobPtr&lt;T&gt;<span style="color: #000000;">;
    friend </span><span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>==&lt;T&gt; (<span style="color: #0000ff;">const</span> Blob&lt;T&gt;&amp;, <span style="color: #0000ff;">const</span> Blob&lt;T&gt;&amp;<span style="color: #000000;">);
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">using</span> size_type = vector&lt;T&gt;<span style="color: #000000;">::size_type;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">construct function</span>
    Blob():data(make_shared&lt;vector&lt;T&gt;&gt;<span style="color: #000000;">()) { };
    Blob(std::initializer_list</span>&lt;T&gt; il):data(make_shared&lt;vector&lt;T&gt;&gt;<span style="color: #000000;">(il)) { }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">number of elements in Blob</span>
    size_type size() <span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span> data-&gt;<span style="color: #000000;">size(); }
    </span><span style="color: #0000ff;">bool</span> empty() <span style="color: #0000ff;">const</span> { <span style="color: #0000ff;">return</span> data-&gt;<span style="color: #000000;">empty(); }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">add and remove member</span>
    <span style="color: #0000ff;">void</span> push_back(<span style="color: #0000ff;">const</span> T &amp;t) { data-&gt;<span style="color: #000000;">push_back(t); }
    </span><span style="color: #0000ff;">void</span> push_back(T &amp;&amp;t) { data-&gt;<span style="color: #000000;">push_back(std::move(t)); }
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> pop_back() 
    {
        check(</span><span style="color: #800080;">0</span>, <span style="color: #800000;">"</span><span style="color: #800000;">pop_back on empty StrBlob</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        data</span>-&gt;<span style="color: #000000;">pop_back();
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">element access</span>
    T&amp;<span style="color: #000000;"> back()
    {
        check(</span><span style="color: #800080;">0</span>, <span style="color: #800000;">"</span><span style="color: #800000;">back on empty StrBlob</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> data-&gt;<span style="color: #000000;">back();
    }
    T</span>&amp; <span style="color: #0000ff;">operator</span><span style="color: #000000;">[](size_type i) {
        check(i, </span><span style="color: #800000;">"</span><span style="color: #800000;">out of range!</span><span style="color: #800000;">"</span><span style="color: #000000;">); 
        </span><span style="color: #0000ff;">return</span> (*<span style="color: #000000;">data)[i]; }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    std::shared_ptr</span>&lt;std::vector&lt;T&gt;&gt;<span style="color: #000000;"> data;
    </span><span style="color: #0000ff;">void</span> check(size_type i, <span style="color: #0000ff;">const</span> std::<span style="color: #0000ff;">string</span> &amp;msg) <span style="color: #0000ff;">const</span><span style="color: #000000;">;
};
</span><span style="color: #008000;">//</span><span style="color: #008000;">在类外必须使用实例化之后的类型Blob&lt;T&gt;</span>
template&lt;typename T&gt;
<span style="color: #0000ff;">void</span> Blob&lt;T&gt;::check(size_type i, <span style="color: #0000ff;">const</span> std::<span style="color: #0000ff;">string</span> &amp; msg) <span style="color: #0000ff;">const</span><span style="color: #000000;">
{
    </span><span style="color: #0000ff;">if</span> (i &gt;= data-&gt;<span style="color: #000000;">size())
        throwout_of_range(msg);
}
template </span>&lt;typename T&gt;
<span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>==(<span style="color: #0000ff;">const</span> Blob&lt;T&gt; lhs, <span style="color: #0000ff;">const</span> Blob&lt;T&gt;<span style="color: #000000;"> rhs)
{
    </span><span style="color: #0000ff;">if</span> (rhs.size() !=<span style="color: #000000;"> lhs.size())
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">for</span> (size_t i = <span style="color: #800080;">0</span>; i &lt; lhs.size(); ++<span style="color: #000000;">i) {
        </span><span style="color: #0000ff;">if</span> (lhs[i] !=<span style="color: #000000;"> rhs[i])
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span><span style="color: #000000;">;
}

</span><span style="color: #008000;">//</span><span style="color: #008000;"> BlobPtr throws an exception on attempts to access a nonexistent element </span>
template &lt;typename T&gt;
<span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>==(<span style="color: #0000ff;">const</span> BlobPtr&lt;T&gt;&amp;, <span style="color: #0000ff;">const</span> BlobPtr&lt;T&gt;&amp;<span style="color: #000000;">);
template </span>&lt;typename T&gt; <span style="color: #0000ff;">class</span> BlobPtr : <span style="color: #0000ff;">public</span> std::iterator&lt;std::bidirectional_iterator_tag, T&gt;<span style="color: #000000;"> 
{
    friend </span><span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>==&lt;T&gt;(<span style="color: #0000ff;">const</span> BlobPtr&lt;T&gt;&amp;, <span style="color: #0000ff;">const</span> BlobPtr&lt;T&gt;&amp;<span style="color: #000000;">);
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    BlobPtr() : curr(</span><span style="color: #800080;">0</span><span style="color: #000000;">) { }
    BlobPtr(Blob</span>&lt;T&gt; &amp;a, size_t sz = <span style="color: #800080;">0</span><span style="color: #000000;">) : wptr(a.data), curr(sz) { }

    T </span>&amp;<span style="color: #0000ff;">operator</span><span style="color: #000000;">[](std::size_t i)
    {
        auto p </span>= check(i, <span style="color: #800000;">"</span><span style="color: #800000;">subscript out of range</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> (*p)[i];  <span style="color: #008000;">//</span><span style="color: #008000;"> (*p) is the vector to which this object points</span>
<span style="color: #000000;">    }

    </span><span style="color: #0000ff;">const</span> T &amp;<span style="color: #0000ff;">operator</span>[](std::size_t i) <span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        auto p </span>= check(i, <span style="color: #800000;">"</span><span style="color: #800000;">subscript out of range</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> (*p)[i];  <span style="color: #008000;">//</span><span style="color: #008000;"> (*p) is the vector to which this object points</span>
<span style="color: #000000;">    }

    T</span>&amp; <span style="color: #0000ff;">operator</span>*() <span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        auto p </span>= check(curr, <span style="color: #800000;">"</span><span style="color: #800000;">dereference past end</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> (*p)[curr];  <span style="color: #008000;">//</span><span style="color: #008000;"> (*p) is the vector to which this object points</span>
<span style="color: #000000;">    }
    T</span>* <span style="color: #0000ff;">operator</span>-&gt;() <span style="color: #0000ff;">const</span><span style="color: #000000;">
    { </span><span style="color: #008000;">//</span><span style="color: #008000;"> delegate the real work to the dereference operator</span>
        <span style="color: #0000ff;">return</span> &amp;<span style="color: #0000ff;">this</span>-&gt;<span style="color: #0000ff;">operator</span>*<span style="color: #000000;">();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> increment and decrement
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> postfix operators</span>
    BlobPtr <span style="color: #0000ff;">operator</span>++(<span style="color: #0000ff;">int</span><span style="color: #000000;">)
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> no check needed here; the call to prefix increment will do the check</span>
        BlobPtr ret = *<span style="color: #0000ff;">this</span>;   <span style="color: #008000;">//</span><span style="color: #008000;"> save the current value</span>
        ++*<span style="color: #0000ff;">this</span>;     <span style="color: #008000;">//</span><span style="color: #008000;"> advance one element; prefix ++ checks the increment</span>
        <span style="color: #0000ff;">return</span> ret;  <span style="color: #008000;">//</span><span style="color: #008000;"> return the saved state</span>
<span style="color: #000000;">    }
    BlobPtr </span><span style="color: #0000ff;">operator</span>--(<span style="color: #0000ff;">int</span><span style="color: #000000;">)
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> no check needed here; the call to prefix decrement will do the check</span>
        BlobPtr ret = *<span style="color: #0000ff;">this</span>;  <span style="color: #008000;">//</span><span style="color: #008000;"> save the current value</span>
        --*<span style="color: #0000ff;">this</span>;     <span style="color: #008000;">//</span><span style="color: #008000;"> move backward one element; prefix -- checks the decrement</span>
        <span style="color: #0000ff;">return</span> ret;  <span style="color: #008000;">//</span><span style="color: #008000;"> return the saved state</span>
<span style="color: #000000;">    }
    BlobPtr</span>&amp; <span style="color: #0000ff;">operator</span>++<span style="color: #000000;">()
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> if curr already points past the end of the container, can't increment it</span>
        check(curr, <span style="color: #800000;">"</span><span style="color: #800000;">increment past end of BlobPtr</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span>++curr;       <span style="color: #008000;">//</span><span style="color: #008000;"> advance the current state</span>
        <span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }
    BlobPtr</span>&amp; BlobPtr&lt;T&gt;::<span style="color: #0000ff;">operator</span>--<span style="color: #000000;">()
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> if curr is zero, decrementing it will yield an invalid subscript</span>
        --curr;       <span style="color: #008000;">//</span><span style="color: #008000;"> move the current state back one element</span>
        check(-<span style="color: #800080;">1</span>, <span style="color: #800000;">"</span><span style="color: #800000;">decrement past begin of BlobPtr</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">return</span> *<span style="color: #0000ff;">this</span><span style="color: #000000;">;
    }

</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> check returns a shared_ptr to the vector if the check succeeds</span>
    std::shared_ptr&lt;std::vector&lt;T&gt;&gt; check(std::size_t i, <span style="color: #0000ff;">const</span> std::<span style="color: #0000ff;">string</span> &amp;msg) <span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        auto ret </span>= wptr.<span style="color: #0000ff;">lock</span>();   <span style="color: #008000;">//</span><span style="color: #008000;"> is the vector still around?</span>
        <span style="color: #0000ff;">if</span> (!<span style="color: #000000;">ret)
            </span><span style="color: #0000ff;">throw</span> std::runtime_error(<span style="color: #800000;">"</span><span style="color: #800000;">unbound BlobPtr</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        </span><span style="color: #0000ff;">if</span> (i &gt;= ret-&gt;<span style="color: #000000;">size())
            </span><span style="color: #0000ff;">throw</span><span style="color: #000000;"> std::out_of_range(msg);
        </span><span style="color: #0000ff;">return</span> ret; <span style="color: #008000;">//</span><span style="color: #008000;"> otherwise, return a shared_ptr to the vector</span>
<span style="color: #000000;">    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> store a weak_ptr, which means the underlying vector might be destroyed</span>
    std::weak_ptr&lt;std::vector&lt;T&gt;&gt;<span style="color: #000000;"> wptr;
    std::size_t curr;      </span><span style="color: #008000;">//</span><span style="color: #008000;"> current position within the array</span>
<span style="color: #000000;">};
</span><span style="color: #008000;">//</span><span style="color: #008000;"> equality operators</span>
template &lt;typename T&gt;
<span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>==(<span style="color: #0000ff;">const</span> BlobPtr&lt;T&gt; &amp;lhs, <span style="color: #0000ff;">const</span> BlobPtr&lt;T&gt; &amp;<span style="color: #000000;">rhs)
{
    </span><span style="color: #0000ff;">return</span> lhs.wptr.<span style="color: #0000ff;">lock</span>().<span style="color: #0000ff;">get</span>() == rhs.wptr.<span style="color: #0000ff;">lock</span>().<span style="color: #0000ff;">get</span>() &amp;&amp;<span style="color: #000000;">
        lhs.curr </span>==<span style="color: #000000;"> rhs.curr;
}
template </span>&lt;typename T&gt;
<span style="color: #0000ff;">bool</span> <span style="color: #0000ff;">operator</span>!=(<span style="color: #0000ff;">const</span> BlobPtr&lt;T&gt; &amp;lhs, <span style="color: #0000ff;">const</span> BlobPtr&lt;T&gt; &amp;<span style="color: #000000;">rhs)
{
    </span><span style="color: #0000ff;">return</span> !(lhs ==<span style="color: #000000;"> rhs);
}</span></pre>
</div>
<span class="cnblogs_code_collapse">类模板示例</span></div>
<h3>16.1.3模板参数</h3>
<p>模板参数的作用域在声明之后定义结束之前。</p>
<p>模板参数可以覆盖外部作用域的类型参数。</p>
<p>模板参数可以有默认值</p>
<p>使用类的类型成员时需要使用typename关键字，如typename T::value_type()</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">默认模板参数</span>
template&lt;typename T=<span style="color: #0000ff;">int</span>&gt;
<span style="color: #008000;">//</span><span style="color: #008000;">使用参数类型的类型成员作为返回值的类型</span>
typename vector&lt;T&gt;::size_type differ(vector&lt;T&gt;&amp; lh, vector&lt;T&gt;&amp;<span style="color: #000000;"> rh)
{
    </span><span style="color: #0000ff;">return</span> lh.size() -<span style="color: #000000;"> rh.size();
}</span></pre>
</div>
<h3>16.1.4类的成员也可以是模板</h3>
<p>普通类中的成员可以为模板</p>
<p>模板类中的成员可以为模板</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">为了在unique_ptr析构对象的时候打印出来信息</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> DebugDelete
{
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    DebugDelete(std::ostream</span>&amp;s =<span style="color: #000000;"> std::cerr) :os(s) {}
    template </span>&lt;typename T&gt; <span style="color: #0000ff;">void</span> <span style="color: #0000ff;">operator</span>()(T*p)<span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        os </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">deleting unique_ptr</span><span style="color: #800000;">"</span> &lt;&lt;<span style="color: #000000;"> std::endl;
        </span><span style="color: #0000ff;">delete</span><span style="color: #000000;"> p;
    }
</span><span style="color: #0000ff;">private</span><span style="color: #000000;">:
    std::ostream </span>&amp;<span style="color: #000000;">os;
};
</span><span style="color: #0000ff;">int</span><span style="color: #000000;"> main()
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">会生成一个int版本的DebugDelete实例</span>
    unique_ptr&lt;<span style="color: #0000ff;">int</span>, DebugDelete&gt; p(<span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">, DebugDelete());
    </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<h3>16.1.5控制实例化</h3>
<p>模板被使用的时候才会实例化，其实例可能出现在多个对象文件中，当独立编译的原文件使用相同的模板并提供了相同的模板参数，每个文件都会有一个实例。为了解决这个开销，可以使用显式实例化。</p>
<p>extern template declaration; //实例化的声明</p>
<p>template declaration;//实例化的定义</p>
<p>编译器遇到external声明，将会在其他位置寻找定义，但在其他位置必须有一个定义。</p>
<p><strong>实例化定义会实例化所有成员，所以类型必须能够引用所有成员函数</strong></p>
<h2>16.2模板实参推断</h2>
<ol>
<li>在调用模板的时候，一般不会发生参数类型的转换。会发生的转换有两种，非const转换成const，数组或函数名转换成指针。</li>
<li>如果函数参数不是模板参数类型，这个参数是可以进行类型转换的</li>
<li>使用相同模板参数类型的函数形参类型必须相同，不会进行参数转换</li>
<li>当模板实参类型无法推断，例如返回值类型时，必须显式指定。（通过fun&lt;typename, &hellip;&gt;）</li>
<li>显式指定了模板实参类型的，也可以进行类型转换（fun&lt;double&gt;(15)，15转换为double）。</li>
</ol>
<h3>16.2.3尾置返回类型与类型转换</h3>
<p>有时候返回值的类型与参数的类型有关，这时候可以用尾置返回类型</p>
<div class="cnblogs_code">
<pre>template &lt;typename It&gt;<span style="color: #000000;">
auto fcn(It beg, It end) </span>-&gt; decltype(*<span style="color: #000000;">beg)
{
    </span><span style="color: #0000ff;">return</span> *<span style="color: #000000;">beg;
}</span></pre>
</div>
<p>由于解引用运算返回的是引用类型，所以返回值是引用类型。</p>
<p>如果要返回的是值，则使用remove_reference（是一个转换模板，定义在type_traits头文件中）。</p>
<div class="cnblogs_code">
<pre>template &lt;typename It&gt;  <span style="color: #008000;">//</span><span style="color: #008000;">第二个typename表示type成员为类型</span>
auto fcn(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;<span style="color: #000000;">::type
{
    </span><span style="color: #0000ff;">return</span> *<span style="color: #000000;">beg;
}</span></pre>
</div>
<p>其他的类型转换模板请参见<a href="http://www.cplusplus.com/reference/type_traits/">这里</a>。</p>
<h3>16.2.6理解std::move</h3>
<p>Std::move将一个对象转变为右值引用对象。</p>
<div class="cnblogs_code">
<pre>template&lt;<span style="color: #0000ff;">class</span> _Ty&gt;<span style="color: #000000;"> inline
constexpr typename remove_reference</span>&lt;_Ty&gt;::type&amp;&amp;<span style="color: #000000;">
move(_Ty</span>&amp;&amp;<span style="color: #000000;"> _Arg) noexcept
{    </span><span style="color: #008000;">//</span><span style="color: #008000;"> forward _Arg as movable</span>
    <span style="color: #0000ff;">return</span> (static_cast&lt;typename remove_reference&lt;_Ty&gt;::type&amp;&amp;&gt;<span style="color: #000000;">(_Arg));
}</span></pre>
</div>
<p>在调用时</p>
<div class="cnblogs_code">
<pre>std::<span style="color: #0000ff;">string</span> s1(<span style="color: #800000;">"</span><span style="color: #800000;">hi!</span><span style="color: #800000;">"</span><span style="color: #000000;">), s2;
s2 </span>= std::move(std::<span style="color: #0000ff;">string</span>(<span style="color: #800000;">"</span><span style="color: #800000;">bye!</span><span style="color: #800000;">"</span><span style="color: #000000;">));
s2 </span>= std::move(s1);</pre>
</div>
<p>使用调用</p>
<div class="cnblogs_code">
<pre>s2 = std::move(std::<span style="color: #0000ff;">string</span>(<span style="color: #800000;">"</span><span style="color: #800000;">bye!</span><span style="color: #800000;">"</span>));</pre>
</div>
<ol>
<li>推断出模板类型_Ty为string</li>
<li>remove_reference&lt;_Ty&gt;::type为string</li>
<li>move返回类型为string&amp;&amp;<span style="line-height: 1.5;">&nbsp;</span></li>
</ol>
<p>使用调用</p>
<div class="cnblogs_code">
<pre>s2 = std::move(s1);</pre>
</div>
<ol>
<li>推断出模板类型_Ty为string&amp;</li>
<li>remove_reference&lt;_Ty&gt;::type为string</li>
<li>move返回类型为string&amp; &amp;&amp;，折叠后为string&amp;</li>
<li>move函数参数t实例化为string&amp; &amp;&amp;，会折叠为string&amp;</li>
</ol>
<h3>16.2.7转发</h3>
<p>某些函数需要将其一个或多个实参和类型不变地转发给其他函数，包括是否是const以及左值还是右值。</p>
<p>这个模板将一个函数的参数转发到里边的函数。</p>
<div class="cnblogs_code">
<pre>template&lt;typename F,typename T1,typename T2&gt;
<span style="color: #0000ff;">void</span><span style="color: #000000;"> flip1(F f, T1 t1, T2, t2)
{
    f(t2, t1);
}</span></pre>
</div>
<p>这个模板在值传递的实例中是正确的，但是在如下调用：</p>
<div class="cnblogs_code">
<pre>function&lt;<span style="color: #0000ff;">void</span>(<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">int</span>&amp;)&gt; fun = [](<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span>&amp; b) {cout &lt;&lt; a &lt;&lt; ++b &lt;&lt;<span style="color: #000000;"> endl; };
</span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span>, b = <span style="color: #800080;">2</span><span style="color: #000000;">;
flip1(fun, a, b);
cout </span>&lt;&lt; a &lt;&lt; b &lt;&lt; endl;</pre>
</div>
<p>你会发现，函数并没有改变第二个参数的值，没有将引用这个参数类型传入。</p>
<p>&nbsp;</p>
<p>修改模板为</p>
<div class="cnblogs_code">
<pre>template&lt;typename F,typename T1,typename T2&gt;
<span style="color: #0000ff;">void</span> flip1(F f, T1&amp;&amp; t1, T2&amp;&amp;<span style="color: #000000;"> t2)
{
    f(t1, t2);
}</span></pre>
</div>
<p>这也会存在一些情况下的错误</p>
<div class="cnblogs_code">
<pre>function&lt;<span style="color: #0000ff;">void</span>(<span style="color: #0000ff;">int</span>&amp;&amp;, <span style="color: #0000ff;">int</span>&amp;)&gt; fun = [](<span style="color: #0000ff;">int</span> &amp;&amp;a, <span style="color: #0000ff;">int</span>&amp; b) {cout &lt;&lt; a &lt;&lt; ++b &lt;&lt;<span style="color: #000000;"> endl; };
</span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span><span style="color: #000000;">;
flip1(fun, </span><span style="color: #800080;">1</span>, a);</pre>
</div>
<p>1为右值传递到模板flip1中后，作为一个变量的形参，会成为一个左值（变量是左值），左值绑定到fun的第一个右值参数时，会出现错误。</p>
<p>&nbsp;</p>
<p>再次修改为</p>
<div class="cnblogs_code">
<pre>template&lt;typename F,typename T1,typename T2&gt;
<span style="color: #0000ff;">void</span> flip1(F f, T1&amp;&amp; t1, T2&amp;&amp;<span style="color: #000000;"> t2)
{
    f(std::forward</span>&lt;T1&gt;(t1), std::forward&lt;T2&gt;<span style="color: #000000;">(t2));
}</span></pre>
</div>
<p>使用forward，将返回类型为T&amp;&amp;的结果，如果出入为值，则返回为右值，传入为左值引用，则引用折叠后返回左值引用。</p>
<h2>16.3重载与模板</h2>
<p>如下两个模板</p>
<div class="cnblogs_code">
<pre>template&lt;typename T&gt; std::<span style="color: #0000ff;">string</span> debug_rep(<span style="color: #0000ff;">const</span> T&amp;<span style="color: #000000;"> t)
{
    std::ostringstream ret;
    ret </span>&lt;&lt;<span style="color: #000000;"> t;
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ret.str();
}
template</span>&lt;typename T&gt; std::<span style="color: #0000ff;">string</span> debug_rep(T*<span style="color: #000000;"> p)
{
    std::ostringstream ret;
    ret </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">pointer: </span><span style="color: #800000;">"</span> &lt;&lt; p &lt;&lt; <span style="color: #800000;">"</span> <span style="color: #800000;">"</span> &lt;&lt; (p ? debug_rep(*p) : <span style="color: #800000;">"</span><span style="color: #800000;">null pointer</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> ret.str();
}</span></pre>
</div>
<p>如果有调用</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span><span style="color: #000000;">;
std::cout </span>&lt;&lt; debug_rep(a) &lt;&lt; std::endl;</pre>
</div>
<p>只有第一个模板时可行的，则选择第一个实例化</p>
<p>&nbsp;</p>
<p>如果有调用</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span><span style="color: #000000;">;
std::cout </span>&lt;&lt; debug_rep(&amp;a) &lt;&lt; std::endl;</pre>
</div>
<p>则有</p>
<div class="cnblogs_code">
<pre>debug_rep(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span>*&amp;<span style="color: #000000;">)
debug_rep(</span><span style="color: #0000ff;">int</span>*)</pre>
</div>
<p>这两个版本的实例化，由于第一个需要有非const转换到const，所以选择了第二个版本。</p>
<p>&nbsp;</p>
<p>如果有调用</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">const</span> <span style="color: #0000ff;">int</span>* a = &amp;<span style="color: #000000;">b;
std::cout </span>&lt;&lt; debug_rep(a) &lt;&lt; std::endl;</pre>
</div>
<p>则上述两个版本都是精确的，然而debug_rep(T* p)对于这个调用来讲，是更特例的版本，只针对于指针，所以选择最特例话的版本。（从另一个角度讲，(const T&amp; t)适用任何类型，这样debug_rep(T* p)永远不会被使用，这条规则才能使其被使用）</p>
<p>&nbsp;</p>
<p>另外，<strong>非模板函数会优先匹配</strong></p>
<h2>16.4可变参数模板</h2>
<p>一个可变参数模板（variadic template）中可变数目的参数被称为参数包（parameter packet），分为两种参数包：模板参数包（template parameter packet）、函数参数包（function parameter）。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> Args is a template parameter pack; rest is a function parameter pack
</span><span style="color: #008000;">//</span><span style="color: #008000;"> Args represents zero or more template type parameters
</span><span style="color: #008000;">//</span><span style="color: #008000;"> rest represents zero or more function parameters</span>
template &lt;typename T, typename... Args&gt;
<span style="color: #0000ff;">void</span> foo(<span style="color: #0000ff;">const</span> T &amp;t, <span style="color: #0000ff;">const</span> Args&amp;<span style="color: #000000;"> ... rest)
{
    cout </span>&lt;&lt; <span style="color: #0000ff;">sizeof</span>...(Args) &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> number of type parameters</span>
    cout &lt;&lt; <span style="color: #0000ff;">sizeof</span>...(args) &lt;&lt; endl;  <span style="color: #008000;">//</span><span style="color: #008000;"> number of function parameters</span>
}</pre>
</div>
<p>用typename&hellip;表示零或多个类型的列表，一个类型名后边跟省略号，表示非类型参数的列表。如果一个函数参数的类型是模板参数包，则此参数是一个函数参数包，可以用sizeof&hellip;求出参数的个数。</p>
<h3>16.4.1例子，打印所有参数</h3>
<p>第一个模板在第二个模板递归调用的最后一次中，时最为匹配的，调用时终止了第二个模板的递归。</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> function to end the recursion and print the last element
</span><span style="color: #008000;">//</span><span style="color: #008000;"> this function must be declared before the variadic version of print is defined</span>
template&lt;typename T&gt;<span style="color: #000000;">
ostream </span>&amp;print(ostream &amp;os, <span style="color: #0000ff;">const</span> T &amp;<span style="color: #000000;">t)
{
    </span><span style="color: #0000ff;">return</span> os &lt;&lt; t; <span style="color: #008000;">//</span><span style="color: #008000;"> no separator after the last element in the pack</span>
<span style="color: #000000;">}
</span><span style="color: #008000;">//</span><span style="color: #008000;"> this version of print will be called for all but the last element in the pack</span>
template &lt;typename T, typename... Args&gt;<span style="color: #000000;">
ostream </span>&amp;print(ostream &amp;os, <span style="color: #0000ff;">const</span> T &amp;t, <span style="color: #0000ff;">const</span> Args&amp;<span style="color: #000000;">... rest)
{
    os </span>&lt;&lt; t &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">, </span><span style="color: #800000;">"</span>;  <span style="color: #008000;">//</span><span style="color: #008000;"> print the first argument</span>
    <span style="color: #0000ff;">return</span> print(os, rest...); <span style="color: #008000;">//</span><span style="color: #008000;"> recursive call; print the other arguments</span>
}</pre>
</div>
<h3>16.4.2包扩展</h3>
<div class="cnblogs_code">
<pre>template &lt;typename T, typename... Args&gt;<span style="color: #000000;">
ostream </span>&amp;print(ostream &amp;os, <span style="color: #0000ff;">const</span> T &amp;t, <span style="color: #0000ff;">const</span> Args&amp;... rest) <span style="color: #008000;">//</span><span style="color: #008000;">扩展Args，生成参数列表</span>
<span style="color: #000000;">{
    os </span>&lt;&lt; t &lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">, </span><span style="color: #800000;">"</span><span style="color: #000000;">;  
    </span><span style="color: #0000ff;">return</span> print(os, rest...); <span style="color: #008000;">//</span><span style="color: #008000;">扩展实参，形成实参列表</span>
}</pre>
</div>
<p>在扩展实参的时候，还可以这样用</p>
<div class="cnblogs_code">
<pre>print(os, debug_rep(rest)...);</pre>
</div>
<p>可以将扩展出来的每一个参数，执行函数调用</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">return</span> print(os, debug_rep(p1), debug_rep(p2), debug_rep(p3));</pre>
</div>
<h3>16.4.3转发参数包</h3>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> fun haszero or more parameters each of which is
</span><span style="color: #008000;">//</span><span style="color: #008000;"> an rvalue reference to a template parameter type</span>
template&lt;typename... Args&gt;
<span style="color: #0000ff;">void</span> fun(Args&amp;&amp;... args) <span style="color: #008000;">//</span><span style="color: #008000;"> expands Args as a list of rvalue references</span>
<span style="color: #000000;">{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> the argument to work expands both Args and args</span>
    work(std::forward&lt;Args&gt;<span style="color: #000000;">(args)...);
}</span></pre>
</div>
<h2>16.5模板特例化</h2>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> firstversion; can compare any two types</span>
template &lt;typename T&gt; <span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> T&amp;, <span style="color: #0000ff;">const</span> T&amp;<span style="color: #000000;">);
</span><span style="color: #008000;">//</span><span style="color: #008000;"> second version to handle string literals</span>
template&lt;size_t N, size_t M&gt;
<span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>(&amp;)[N], <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>(&amp;)[M]);</pre>
</div>
<p>定义的这两个模板，可以比较任意对象类型。但是，如果传入的是字符串类型的指针（char*）时，回到第一个模板中调用，然而比较了参数指针的大小。</p>
<p>为了能够处理字符指针的类型，可以定义一个特列</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> specialversion of compare to handle pointers to character arrays</span>
template &lt;&gt;
<span style="color: #0000ff;">int</span> compare(<span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* <span style="color: #0000ff;">const</span> &amp;p1, <span style="color: #0000ff;">const</span> <span style="color: #0000ff;">char</span>* <span style="color: #0000ff;">const</span> &amp;<span style="color: #000000;">p2)
{
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> strcmp(p1, p2);
}</span></pre>
</div>
<p align="left">当提供一个特例化，其类型必须与之前的模板参数中对应的类型匹配。如上是为了特例化第一个模板template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);了，其参数是顶层const的，而对于指针类型char*，其参数是底层const，所以在特例化的时候为const char* const &amp;p1。</p>
<p>&nbsp;</p>
<p>需要注意的是，特例化本质是实例化一个模板，而非重载。因此特例化不影响函数匹配。这与将其定义为非模板函数是有区别的。</p>
<p>加入定义了非模板函数，这样在传入字符常量的时候，例如</p>
<div class="cnblogs_code">
<pre>compare(<span style="color: #800000;">"</span><span style="color: #800000;">hi</span><span style="color: #800000;">"</span>, <span style="color: #800000;">"</span><span style="color: #800000;">mom</span><span style="color: #800000;">"</span>);</pre>
</div>
<p>会匹配到我们定义的非模板函数，而这个实际上我们希望匹配到int compare(const char(&amp;)[N], const char(&amp;)[M]);&nbsp;</p>
<p>注意，<strong>特例化必须声明在作用域中，故声明在一个头文件中</strong>。</p>
<p>&nbsp;</p>
<p><strong>类模板的特例化</strong></p>
<p>如果自定义类需要使用无序容器，必须定义自己的hasher版本，或者特例化hash&lt;key_type&gt;版本，一个特例化的hash类必须定义：</p>
<ol>
<li>一个重载调用运算符，接收一个容器关键字类型的对象，返回一个size_t</li>
<li>两个类型成员，result_type和argument_type，分别为调用运算符的返回类型和参数类型</li>
<li>默认构造函数和拷贝赋值运算符（可以隐式定义）。</li>
</ol>
<p>注意，特例化需要与被特例化的模板在同一个作用域，所以使用namespace参数。</p>
<p>示例：对Sales_data</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> openthe std namespace so we can specialize std::hash</span>
<span style="color: #0000ff;">namespace</span><span style="color: #000000;"> std 
{
    template </span>&lt;&gt;  <span style="color: #008000;">//</span><span style="color: #008000;"> we're defining a specialization with</span>
    <span style="color: #0000ff;">struct</span> hash&lt;Sales_data&gt; <span style="color: #008000;">//</span><span style="color: #008000;"> the template parameter of Sales_data</span>
<span style="color: #000000;">    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> the type used to hash an unordered container must define these types</span>
<span style="color: #000000;">        typedef size_t result_type;
        typedef Sales_data argument_type; </span><span style="color: #008000;">//</span><span style="color: #008000;"> by default, this type needs ==</span>
        size_t <span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> Sales_data&amp; s) <span style="color: #0000ff;">const</span><span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> our class uses synthesized copy control and default constructor</span>
<span style="color: #000000;">    };
    size_t hash</span>&lt;Sales_data&gt;::<span style="color: #0000ff;">operator</span>()(<span style="color: #0000ff;">const</span> Sales_data&amp; s) <span style="color: #0000ff;">const</span><span style="color: #000000;">
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">下边是hash函数的算法，使用了string、uint、double的hash算法</span>
        <span style="color: #0000ff;">return</span> hash&lt;<span style="color: #0000ff;">string</span>&gt;()(s.bookNo) ^<span style="color: #000000;">
            hash</span>&lt;unsigned&gt;()(s.units_sold) ^<span style="color: #000000;">
            hash</span>&lt;<span style="color: #0000ff;">double</span>&gt;<span style="color: #000000;">()(s.revenue);
    }
}</span></pre>
</div>
<p>注意，有时候会使用私有成员进行hash，所以声明为友元</p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;"> needed for the friend declaration</span>
template &lt;classT&gt; <span style="color: #0000ff;">class</span><span style="color: #000000;"> std::hash;  
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Sales_data {
    friend </span><span style="color: #0000ff;">class</span> std::hash&lt;Sales_data&gt;<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> other members as before</span>
};</pre>
</div>
<p>&nbsp;</p>
<p><strong>类模板的部分特例化</strong></p>
<p>我们可以部分特例化类模板，不能部分特例化函数模板</p>
<div class="cnblogs_code">
<pre>template &lt;<span style="color: #0000ff;">class</span> T&gt; <span style="color: #0000ff;">struct</span><span style="color: #000000;"> remove_reference {
    typedef T type;
};
</span><span style="color: #008000;">//</span><span style="color: #008000;"> partialspecializations that will be used for lvalue and rvalue references</span>
template &lt;<span style="color: #0000ff;">class</span> T&gt; <span style="color: #0000ff;">struct</span> remove_reference&lt;T&amp;&gt;  <span style="color: #008000;">//</span><span style="color: #008000;"> lvalue references</span>
<span style="color: #000000;">{
    typedef T type;
};
template </span>&lt;<span style="color: #0000ff;">class</span> T&gt; <span style="color: #0000ff;">struct</span> remove_reference&lt;T&amp;&amp;&gt; <span style="color: #008000;">//</span><span style="color: #008000;"> rvalue references</span>
<span style="color: #000000;">{
    typedef T type;
};</span></pre>
</div>
<p><strong>特例化模板的成员</strong></p>
<div class="cnblogs_code">
<pre>template &lt;typename T&gt; <span style="color: #0000ff;">struct</span><span style="color: #000000;"> Foo {
    Foo(constT </span>&amp;t =<span style="color: #000000;"> T()) : mem(t) { }
    </span><span style="color: #0000ff;">void</span> Bar() { <span style="color: #008000;">/*</span><span style="color: #008000;"> ...</span><span style="color: #008000;">*/</span><span style="color: #000000;"> }
    T mem;
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> other members of Foo</span>
<span style="color: #000000;">};
template</span>&lt;&gt;  <span style="color: #008000;">//</span><span style="color: #008000;"> we're specializing a template</span>
<span style="color: #0000ff;">void</span> Foo&lt;<span style="color: #0000ff;">int</span>&gt;::Bar() <span style="color: #008000;">//</span><span style="color: #008000;"> we're specializing the Bar member of Foo&lt;int&gt;</span>
<span style="color: #000000;">{
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> do whatever specialized processing that applies to ints</span>
}</pre>
</div>
<p>当使用int类型的模板时，会使用这个特例化的Bar()函数成员。</p>
